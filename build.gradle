apply plugin: 'c'
apply plugin: 'java'

import java.io.FileInputStream;
import java.io.FileOutputStream;
import java.io.IOException;
import java.util.zip.GZIPInputStream;
import java.util.zip.GZIPOutputStream;

model {
    buildTypes {
        release
    }
    
    components {
        abootimg(NativeExecutableSpec) {
            binaries.all {
                cppCompiler.define 'HAS_BLKID'
                linker.args "-lblkid"
            }
        }
    }

    components {
        mkbootfs(NativeExecutableSpec) {
            binaries.all {
            }
        }
    }
}

def workdir='unzip_boot'
task unpack_bootimg(type: Exec, dependsOn: 'abootimgExecutable') {
    new File(workdir + '/root').mkdirs()
    workingDir '.'
    executable 'build/exe/abootimg/abootimg'
    args = ['-x', 'boot.img', workdir+'/bootimg.cfg', workdir+'/kernel', workdir+'/ramdisk.img.gz'] 
}

task unpack_ramdisk_gz << {
    unGnuzipFile(workdir+"/ramdisk.img.gz", workdir + "/ramdisk.img")
}
unpack_ramdisk_gz.dependsOn(unpack_bootimg)

//task unpack_cpio(type: Exec, dependsOn: unpack_ramdisk_gz) {
task unpack_cpio(type: Exec) {
    workingDir workdir + "/root"
    executable 'cpio'
    args = ['-i', '-F', '../ramdisk.img']
}

task unpack(type: Delete, dependsOn: unpack_cpio) {
  delete workdir + "/ramdisk.img.gz"
}

task pack_ramdisk_and_gz { Task task ->
    doLast {
        ByteArrayOutputStream mkbootfs_out = new ByteArrayOutputStream()
        task.project.exec {
            commandLine = [
                'build/exe/mkbootfs/mkbootfs', workdir + "/root"
            ]
            standardOutput = mkbootfs_out 
        }
        def ByteArrayInputStream gzip_in = new ByteArrayInputStream(mkbootfs_out.buf)
        gnuZipFile(workdir + "/ramdisk.img.gz", gzip_in)
    }
}

task featuresWaiting(type: Exec) {
    commandLine 'build/exe/mkbootimg/mkbootimg', \
        '--kernel', workdir + "/kernel", \
        '--ramdisk', workdir + "/ramdisk.img.gz", \
        '--cmdline', "cmdlineeeee", \
        '--base', '0x01000000', \
        '--output', 'out'
}

public void unGnuzipFile(String compressedFile, String decompressedFile) throws IOException {
    byte[] buffer = new byte[1024];
    try {
        FileInputStream fileIn = new FileInputStream(compressedFile);
        GZIPInputStream gZIPInputStream = new GZIPInputStream(fileIn);
        FileOutputStream fileOutputStream = new FileOutputStream(decompressedFile);
        int bytes_read;
        while ((bytes_read = gZIPInputStream.read(buffer)) > 0) {
            fileOutputStream.write(buffer, 0, bytes_read);
        }
        gZIPInputStream.close();
        fileOutputStream.close();
        System.out.println("The file was decompressed successfully!");
    } catch (IOException ex) {
        throw ex;
    }
}

public void gnuZipFile(String compressedFile, InputStream fis) throws IOException {
    byte[] buffer = new byte[1024];
    try {
        FileOutputStream fos = new FileOutputStream(compressedFile);
        GZIPOutputStream gos = new GZIPOutputStream(fos);

        int bytes_read;
        while ((bytes_read = fis.read(buffer)) > 0) {
            gos .write(buffer, 0, bytes_read);
        }
        gos.finish();
        gos.close();
        System.out.println("The file compressed successfully!");
    } catch (IOException ex) {
        throw ex;
    }
}

public void gnuZipFile(String compressedFile, String decompressedFile) throws IOException {
    byte[] buffer = new byte[1024];
    try {
        FileOutputStream fos = new FileOutputStream(compressedFile);
        GZIPOutputStream gos = new GZIPOutputStream(fos);

        FileInputStream fis = new FileInputStream(decompressedFile);
        int bytes_read;
        while ((bytes_read = fis.read(buffer)) > 0) {
            gos .write(buffer, 0, bytes_read);
        }
        fis.close();
        gos.finish();
        gos.close();
        System.out.println("The file compressed successfully!");
    } catch (IOException ex) {
        throw ex;
    }
}
